<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>How LLMs Actually Work</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&display=swap"
    />
    <style>
      :root {
        --paper: #fafaf8;
        --ink: #1a1a18;
        --ink2: #6b6b66;
        --ink3: #b8b4aa;
        --ink4: #ddd9d0;
        --seed: #edeadf;
        --seedh: #e4e0d4;
        --hl: #fff3c4;
        --acc: #4a6741;
        --paper-warm: #faf8f2;
        --bg-temp: 0;
        --t-page: 0.2s;
        --t-step: 0.4s;
        --t-whisper: 0.6s;
        --t-constellation: 0.6s;
        --t-liminal-in: 0.2s;
        --t-liminal-out: 0.2s;
        --t-dwell: 0.4s;
        --t-scatter: 0.6s;
        --t-ghostfade: 0.3s;
        --t-engagement: 0.2s;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: color-mix(in srgb, var(--paper) calc((1 - var(--bg-temp)) * 100%), var(--paper-warm));
        color: var(--ink);
        font-family: "Lora", Georgia, serif;
        font-size: 18px;
        line-height: 1.65;
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      ::selection {
        background: var(--hl);
      }

      :focus-visible {
        outline: 2px solid var(--ink);
        outline-offset: 2px;
      }

      .view {
        opacity: 0;
        transition: opacity var(--t-page) ease;
      }

      .view.is-visible {
        opacity: 1;
      }

      .landing,
      .plateau {
        min-height: 100vh;
        padding: 72px 24px 96px;
      }

      .landing {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
      }

      .landing-header {
        text-align: center;
        max-width: 42rem;
      }

      .landing-header h1 {
        font-size: clamp(2.4rem, 4vw, 3.2rem);
        font-weight: 600;
        letter-spacing: -0.02em;
        margin: 0 0 0.35rem;
      }

      .landing-header .subtitle {
        font-style: italic;
        color: var(--ink2);
        margin: 0 0 1.25rem;
        font-size: 1.05rem;
      }

      .landing-header p {
        margin: 0;
        color: var(--ink);
      }

      .landing-map {
        width: min(460px, 100%);
      }

      .map-wrap {
        position: relative;
        width: 100%;
        aspect-ratio: 460 / 360;
      }

      .map-wrap canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .map-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .map-link {
        position: absolute;
        width: 44px;
        height: 44px;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        pointer-events: auto;
      }

      .map-link:focus-visible {
        outline-offset: 4px;
      }

      .map-note {
        margin-top: 16px;
        color: var(--ink2);
        font-size: 0.95rem;
        font-style: italic;
        text-align: center;
      }

      .mini-map {
        position: fixed;
        right: 32px;
        bottom: 32px;
        width: 160px;
        height: 120px;
        border-radius: 16px;
        border: 1px solid var(--ink4);
        background: color-mix(in srgb, var(--paper) 92%, white 8%);
        box-shadow: 0 14px 30px rgba(26, 26, 24, 0.08);
        overflow: hidden;
        z-index: 20;
      }

      .mini-map canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .mini-map-button {
        position: absolute;
        inset: 0;
        border: none;
        background: transparent;
        border-radius: inherit;
        cursor: pointer;
      }

      .rhizome-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--t-page) ease;
        z-index: 40;
      }

      .rhizome-overlay.is-open {
        opacity: 1;
        pointer-events: auto;
      }

      .overlay-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(250, 250, 248, 0.82);
        backdrop-filter: blur(10px);
      }

      .overlay-panel {
        position: relative;
        z-index: 1;
        background: rgba(250, 250, 248, 0.96);
        border: 1px solid var(--ink4);
        border-radius: 24px;
        padding: 32px;
        box-shadow: 0 30px 80px rgba(26, 26, 24, 0.18);
      }

      .overlay-map {
        position: relative;
        width: min(90vw, 700px);
        aspect-ratio: 700 / 550;
      }

      .overlay-map canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .overlay-links {
        position: absolute;
        inset: 0;
      }

      .overlay-link {
        position: absolute;
        width: 44px;
        height: 44px;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        opacity: 0;
      }

      .overlay-link:focus-visible {
        opacity: 1;
        background: rgba(74, 103, 65, 0.12);
        outline-offset: 4px;
      }

      .overlay-link:hover {
        opacity: 1;
        background: rgba(74, 103, 65, 0.08);
      }

      .overlay-close {
        position: absolute;
        top: 16px;
        right: 16px;
        border: 1px solid var(--ink4);
        background: var(--paper);
        color: var(--ink2);
        border-radius: 999px;
        padding: 0.4rem 0.9rem;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        cursor: pointer;
      }

      body.overlay-open {
        overflow: hidden;
      }

      .plateau {
        max-width: 42rem;
        margin: 0 auto;
      }

      .entry-question {
        margin-top: 0.75rem;
        color: var(--ink2);
        font-style: italic;
      }

      .scrolly {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0;
        margin-top: 48px;
        border-top: 1px solid var(--ink4);
      }

      .scrolly-viz {
        position: sticky;
        top: 0;
        height: 100vh;
        border-right: 1px solid var(--ink4);
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(180deg, rgba(250, 250, 248, 0.9), rgba(250, 250, 248, 0.98));
        overflow: hidden;
      }

      .viz-main {
        width: min(380px, 90%);
        min-height: 240px;
        border: 1px solid var(--ink4);
        border-radius: 20px;
        display: grid;
        place-items: center;
        color: var(--ink2);
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        transition: opacity var(--t-constellation) ease;
      }

      .scrolly-viz.is-constellation .viz-main {
        opacity: 0.2;
      }

      .scrolly-steps {
        padding: 0 36px;
      }

      .scrolly-step {
        min-height: 65vh;
        display: flex;
        align-items: center;
        color: var(--ink3);
        transition: color var(--t-step) ease;
      }

      .scrolly-step.is-active {
        color: var(--ink);
      }

      .whisper-layer {
        position: absolute;
        right: 22px;
        top: 18%;
        display: flex;
        flex-direction: column;
        gap: 12px;
        text-align: right;
        font-style: italic;
        color: var(--ink2);
        font-size: 0.82rem;
      }

      .whisper {
        opacity: 0;
        transform: translateX(8px);
        transition: opacity var(--t-whisper) ease, transform var(--t-whisper) ease;
      }

      .whisper.is-visible {
        opacity: 1;
        transform: translateX(0);
      }

      .trace-pips {
        position: absolute;
        right: 12px;
        top: 18%;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .trace-pip {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: var(--ink4);
      }

      .trace-pip.is-lit {
        background: var(--ink);
      }

      .constellation {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        opacity: 0;
        transition: opacity var(--t-constellation) ease;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        color: var(--ink2);
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 0.8rem;
      }

      .constellation.is-visible {
        opacity: 1;
      }

      .question-cards {
        margin-top: 32px;
        display: grid;
        gap: 14px;
      }

      .question-card {
        border: 1px solid var(--ink4);
        border-radius: 14px;
        padding: 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        color: var(--ink2);
        transition: border-color 0.2s ease, transform 0.2s ease;
      }

      .question-card:hover {
        border-color: var(--ink2);
        transform: translateY(-1px);
      }

      .question-card span {
        font-style: italic;
        color: var(--ink);
        font-family: "Lora", Georgia, serif;
      }

      .seed-field {
        margin-top: 32px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .seed-item {
        border: 1px solid var(--ink4);
        border-radius: 16px;
        padding: 14px 16px;
        background: rgba(237, 234, 223, 0.4);
      }

      .seed-button {
        border: none;
        background: var(--seed);
        color: var(--ink);
        font-family: "Lora", Georgia, serif;
        font-size: 1rem;
        padding: 6px 10px;
        border-radius: 999px;
        border-bottom: 1px dotted var(--ink2);
        cursor: pointer;
      }

      .seed-button:hover {
        background: var(--seedh);
      }

      .seed-growth {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.35s ease;
      }

      .seed-growth.is-open {
        max-height: 220px;
      }

      .seed-growth-inner {
        margin-top: 12px;
        padding-left: 14px;
        border-left: 2px solid var(--ink4);
        color: var(--ink2);
      }

      .inline-seed {
        display: inline;
      }

      .inline-seed-button {
        border: none;
        background: var(--seed);
        color: inherit;
        font: inherit;
        padding: 0 4px;
        border-radius: 6px;
        border-bottom: 1px dotted var(--ink2);
        cursor: pointer;
      }

      .inline-seed-button:hover {
        background: var(--seedh);
      }

      .inline-seed-growth {
        display: block;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.35s ease;
      }

      .inline-seed-growth.is-open {
        max-height: 180px;
      }

      .inline-seed-content {
        display: block;
        margin-top: 10px;
        padding-left: 12px;
        border-left: 2px solid var(--ink4);
        color: var(--ink2);
      }

      .plateau .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        font-size: 0.85rem;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: var(--ink2);
      }

      .plateau h1 {
        margin-top: 1.5rem;
        font-size: 2.2rem;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        border: 0;
        padding: 0;
        white-space: nowrap;
        clip-path: inset(100%);
        clip: rect(0 0 0 0);
        overflow: hidden;
      }

      /* Question-seed: italic label with dotted underline */
      .inline-seed-button[data-seed-type="question"] {
        font-style: italic;
        border-bottom-style: dotted;
      }

      /* Seed growth for question-seeds */
      .seed-button[data-seed-type="question"] {
        font-style: italic;
        border-bottom-style: dotted;
      }

      /* Dangling reference trailing link */
      .dangling-link {
        font-style: italic;
        color: var(--ink2);
        border-bottom: 1px dotted var(--ink2);
        cursor: pointer;
      }

      .dangling-link:hover {
        color: var(--ink);
      }

      /* Liminal transition overlay */
      .liminal-transition {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
        opacity: 0;
        background: rgba(250, 250, 248, 0.88);
        backdrop-filter: blur(12px);
        transition: opacity var(--t-liminal-in) ease;
        pointer-events: none;
      }

      .liminal-transition.is-visible {
        opacity: 1;
      }

      .liminal-transition.is-fading {
        opacity: 0;
        transition: opacity var(--t-liminal-out) ease;
      }

      .liminal-question {
        font-style: italic;
        color: var(--ink);
        font-size: 1.1rem;
        max-width: 32rem;
        text-align: center;
        line-height: 1.7;
        padding: 0 24px;
      }

      /* Ghostfading visited concepts */
      .ghostfaded {
        opacity: 0.85;
        transition: opacity var(--t-ghostfade) ease;
      }

      .ghostfaded .inline-seed-button,
      .ghostfaded .seed-button,
      .ghostfaded a {
        opacity: 1;
      }

      /* Engagement state counter */
      .engagement-state {
        color: var(--ink3);
        font-size: 0.72rem;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        margin-top: 16px;
        opacity: 1;
        transition: opacity var(--t-engagement) ease;
      }

      /* Dwell-reveal annotations */
      .dwell-annotation {
        position: absolute;
        right: -180px;
        top: 0;
        width: 160px;
        font-style: italic;
        color: var(--ink3);
        font-size: 0.78rem;
        line-height: 1.5;
        opacity: 0;
        transition: opacity var(--t-dwell) ease;
      }

      .dwell-annotation.is-revealed {
        opacity: 1;
      }

      .dwell-target {
        position: relative;
      }

      /* Author marginalia */
      .plateau-with-marginalia {
        max-width: 54rem;
        display: grid;
        grid-template-columns: 1fr 180px;
        gap: 0 32px;
      }

      .plateau-with-marginalia > * {
        grid-column: 1;
      }

      .marginalia {
        grid-column: 2;
        font-style: italic;
        color: var(--ink3);
        font-size: 0.78rem;
        line-height: 1.5;
        align-self: start;
        padding-top: 4px;
      }

      /* Cross-plateau retrieval moment */
      .retrieval-moment {
        background: var(--seed);
        color: var(--ink2);
        border-top: 2px solid var(--ink4);
        border-radius: 0 0 12px 12px;
        padding: 14px 18px;
        margin-bottom: 24px;
        font-size: 0.92rem;
        line-height: 1.6;
        display: flex;
        align-items: flex-start;
        gap: 12px;
        opacity: 1;
        transition: opacity 0.3s ease;
      }

      .retrieval-moment.is-dismissed {
        opacity: 0;
        pointer-events: none;
      }

      .retrieval-close {
        border: 1px solid var(--ink4);
        background: transparent;
        color: var(--ink3);
        border-radius: 999px;
        width: 24px;
        height: 24px;
        font-size: 0.7rem;
        cursor: pointer;
        flex-shrink: 0;
        display: grid;
        place-items: center;
        font-family: system-ui, sans-serif;
      }

      .retrieval-close:hover {
        color: var(--ink2);
        border-color: var(--ink2);
      }

      /* Micro-CYOA forks */
      .cyoa-fork {
        margin-top: 24px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .cyoa-option {
        border: 1px solid var(--ink4);
        border-radius: 14px;
        padding: 14px 18px;
        background: transparent;
        font: inherit;
        text-align: left;
        cursor: pointer;
        color: var(--ink2);
        opacity: 0.7;
        transition: opacity 0.2s ease, border-color 0.2s ease;
      }

      .cyoa-option:hover {
        border-color: var(--ink2);
      }

      .cyoa-option.is-chosen {
        opacity: 1;
        color: var(--ink);
        border-color: var(--ink);
      }

      .cyoa-option.is-unchosen {
        opacity: 0.7;
        color: var(--ink2);
      }

      .cyoa-option:not(.is-chosen):not(.is-unchosen) {
        opacity: 1;
        color: var(--ink);
      }

      .cyoa-expansion {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.35s ease;
      }

      .cyoa-expansion.is-open {
        max-height: 300px;
      }

      .cyoa-expansion-inner {
        margin-top: 10px;
        padding-left: 14px;
        border-left: 2px solid var(--ink4);
        color: var(--ink2);
      }

      /* Scatter-to-text */
      .scatter-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .scatter-word {
        position: absolute;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--ink2);
        text-transform: uppercase;
        letter-spacing: 0.06em;
        transition: transform var(--t-scatter) ease;
        white-space: nowrap;
      }

      @media (max-width: 600px) {
        .landing,
        .plateau {
          padding-top: 56px;
        }

        .landing-header h1 {
          font-size: 2.2rem;
        }
      }

      @media (max-width: 840px) {
        .scrolly {
          grid-template-columns: 1fr;
        }

        .scrolly-viz {
          height: 42vh;
          border-right: none;
          border-bottom: 1px solid var(--ink4);
        }

        .scrolly-steps {
          padding: 0 20px;
        }

        .plateau-with-marginalia {
          grid-template-columns: 1fr;
        }

        .marginalia {
          grid-column: 1;
          padding-left: 24px;
          margin-top: -8px;
          margin-bottom: 12px;
        }

        .dwell-annotation {
          position: static;
          width: auto;
          margin-top: 8px;
          padding-left: 12px;
          border-left: 2px solid var(--ink4);
        }
      }

      @media (max-width: 480px) {
        .mini-map {
          width: 44px;
          height: 44px;
          border-radius: 50%;
          right: 20px;
          bottom: 20px;
        }

        .scrolly-viz {
          height: 38vh;
        }

        .whisper-layer,
        .trace-pips {
          display: none;
        }

        .dwell-annotation {
          display: none;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        :root {
          --t-page: 0s;
          --t-step: 0s;
          --t-whisper: 0s;
          --t-constellation: 0s;
          --t-liminal-in: 0s;
          --t-liminal-out: 0s;
          --t-dwell: 0s;
          --t-scatter: 0s;
          --t-ghostfade: 0s;
          --t-engagement: 0s;
          --bg-temp: 0 !important;
        }

        *,
        *::before,
        *::after {
          transition-duration: 0s !important;
          animation-duration: 0s !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script>
      const GRAPH = {
        nodes: [
          { id: "next-word", title: "The Next Word", label: "Next Word", shortQ: "What does it do when it talks?", x: 0.5, y: 0.08 },
          { id: "understanding-illusion", title: "The Understanding Illusion", label: "Understanding", shortQ: "Does it understand?", x: 0.78, y: 0.28 },
          { id: "averaging-problem", title: "The Averaging Problem", label: "Averaging", shortQ: "Best essay or average essay?", x: 0.5, y: 0.44 },
          { id: "weight-of-words", title: "The Weight of Words", label: "Weight", shortQ: "How does it learn from words?", x: 0.2, y: 0.62 },
          { id: "the-shaping", title: "The Shaping", label: "Shaping", shortQ: "Autocomplete to assistant?", x: 0.5, y: 0.62 },
          { id: "quality", title: "What Is Quality?", label: "Quality", shortQ: "Who decides what's good?", x: 0.8, y: 0.62 },
          { id: "practical-guide", title: "The Field Guide", label: "Field Guide", shortQ: "What do I actually do?", x: 0.35, y: 0.85 },
          { id: "tool-user", title: "The Tool-User", label: "Tool-User", shortQ: "What if it can use tools?", x: 0.65, y: 0.85 },
        ],
        edges: [
          ["next-word", "averaging-problem"],
          ["next-word", "understanding-illusion"],
          ["next-word", "weight-of-words"],
          ["averaging-problem", "the-shaping"],
          ["averaging-problem", "practical-guide"],
          ["averaging-problem", "understanding-illusion"],
          ["averaging-problem", "weight-of-words"],
          ["the-shaping", "weight-of-words"],
          ["the-shaping", "quality"],
          ["the-shaping", "practical-guide"],
          ["the-shaping", "tool-user"],
          ["quality", "understanding-illusion"],
          ["quality", "practical-guide"],
          ["understanding-illusion", "practical-guide"],
          ["understanding-illusion", "tool-user"],
          ["practical-guide", "weight-of-words"],
          ["practical-guide", "tool-user"],
        ],
      };

      const STORAGE_KEY = "le5";
      const app = document.querySelector("#app");
      let activeCleanup = () => {};

      const h = (tag, attrs, ...children) => {
        const el = document.createElement(tag);
        if (attrs) {
          Object.entries(attrs).forEach(([key, value]) => {
            if (value === null || value === undefined) return;
            if (key === "class") {
              el.className = value;
              return;
            }
            if (key === "style" && typeof value === "object") {
              Object.assign(el.style, value);
              return;
            }
            if (key.startsWith("on") && typeof value === "function") {
              el.addEventListener(key.slice(2), value);
              return;
            }
            el.setAttribute(key, value);
          });
        }
        children.flat().forEach((child) => {
          if (child === null || child === undefined) return;
          if (typeof child === "string") {
            el.appendChild(document.createTextNode(child));
          } else {
            el.appendChild(child);
          }
        });
        return el;
      };

      const loadState = () => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return { v: [], tr: [], si: {}, eg: {} };
          const parsed = JSON.parse(raw);
          if (!parsed || !Array.isArray(parsed.v) || !Array.isArray(parsed.tr)) {
            throw new Error("Invalid state");
          }
          return {
            v: parsed.v,
            tr: parsed.tr,
            si: parsed.si && typeof parsed.si === "object" ? parsed.si : {},
            eg: parsed.eg && typeof parsed.eg === "object" ? parsed.eg : {},
          };
        } catch (error) {
          return { v: [], tr: [], si: {}, eg: {} };
        }
      };

      const saveState = (state) => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      };

      const recordVisit = (state, plateauId) => {
        if (!state.v.includes(plateauId)) {
          state.v.push(plateauId);
        }
        state.tr.push({ p: plateauId, t: Date.now() });
        saveState(state);
      };

      const recordSeedOpen = (state, plateauId, seedId) => {
        if (!state.si[plateauId]) state.si[plateauId] = [];
        if (state.si[plateauId].includes(seedId)) return false;
        state.si[plateauId].push(seedId);
        if (!state.eg[plateauId]) state.eg[plateauId] = { opened: 0, total: 0 };
        state.eg[plateauId].opened++;
        saveState(state);
        return true;
      };

      const initEngagement = (state, plateauId, totalSeeds) => {
        if (!state.eg[plateauId]) state.eg[plateauId] = { opened: 0, total: 0 };
        state.eg[plateauId].total = totalSeeds;
        saveState(state);
      };

      const getPlateau = (id) => GRAPH.nodes.find((node) => node.id === id);

      const scaleCanvas = (canvas, width, height) => {
        const ratio = window.devicePixelRatio || 1;
        canvas.width = Math.floor(width * ratio);
        canvas.height = Math.floor(height * ratio);
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        return ratio;
      };

      const getNodePx = (node, width, height) => ({
        x: node.x * width,
        y: node.y * height,
      });

      const getTrailSegments = (trail) => {
        const seen = new Set();
        const ordered = [];
        trail.forEach((entry) => {
          if (seen.has(entry.p)) return;
          seen.add(entry.p);
          const node = getPlateau(entry.p);
          if (node) ordered.push(node);
        });
        return ordered;
      };

      const drawGraph = ({
        canvas,
        width,
        height,
        visited,
        activeId,
        highlightIds,
        edgeFilter,
        showLabels,
        showTrail,
        trailNodes,
        useQuestionLabels,
      }) => {
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        const ratio = scaleCanvas(canvas, width, height);
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        ctx.clearRect(0, 0, width, height);

        const styles = getComputedStyle(document.documentElement);
        const ink = styles.getPropertyValue("--ink").trim();
        const ink4 = styles.getPropertyValue("--ink4").trim();
        const acc = styles.getPropertyValue("--acc").trim();
        const paper = styles.getPropertyValue("--paper").trim();
        const labelFont = "12px system-ui, -apple-system, Segoe UI, sans-serif";

        ctx.strokeStyle = ink4;
        ctx.lineWidth = 1;
        GRAPH.edges.forEach(([fromId, toId]) => {
          if (edgeFilter && !edgeFilter(fromId, toId)) return;
          if (highlightIds && (!highlightIds.has(fromId) || !highlightIds.has(toId))) return;
          const from = GRAPH.nodes.find((node) => node.id === fromId);
          const to = GRAPH.nodes.find((node) => node.id === toId);
          if (!from || !to) return;
          const fromPos = getNodePx(from, width, height);
          const toPos = getNodePx(to, width, height);
          ctx.beginPath();
          ctx.moveTo(fromPos.x, fromPos.y);
          ctx.lineTo(toPos.x, toPos.y);
          ctx.stroke();
        });

        if (showTrail && trailNodes && trailNodes.length > 1) {
          ctx.strokeStyle = acc;
          ctx.lineWidth = 2;
          ctx.beginPath();
          trailNodes.forEach((node, index) => {
            const pos = getNodePx(node, width, height);
            if (index === 0) {
              ctx.moveTo(pos.x, pos.y);
            } else {
              ctx.lineTo(pos.x, pos.y);
            }
          });
          ctx.stroke();
        }

        GRAPH.nodes.forEach((node) => {
          if (highlightIds && !highlightIds.has(node.id)) return;
          const pos = getNodePx(node, width, height);
          const isVisited = visited.has(node.id);
          const isActive = node.id === activeId;
          const radius = isActive ? 11.5 : 8.5;

          ctx.beginPath();
          ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = isVisited || isActive ? ink : paper;
          ctx.strokeStyle = ink;
          ctx.lineWidth = 1.3;
          ctx.fill();
          ctx.stroke();

          if (showLabels) {
            const labelText = useQuestionLabels && node.shortQ ? node.shortQ : node.label;
            const labelFontSize = useQuestionLabels ? "10px" : "12px";
            ctx.font = `${labelFontSize} system-ui, -apple-system, Segoe UI, sans-serif`;
            ctx.fillStyle = ink;
            ctx.textBaseline = "middle";
            const alignRight = node.x > 0.68;
            ctx.textAlign = alignRight ? "right" : "left";
            const offset = alignRight ? -14 : 14;
            ctx.fillText(labelText, pos.x + offset, pos.y);
          }
        });
      };

      const ENTRY_QUESTIONS = {
        "next-word": "What is an LLM actually doing when it \"talks\" to you?",
        "averaging-problem": "If you learn from a million essays, do you write like the best one or the average one?",
        "the-shaping": "What happened between \"raw autocomplete\" and \"helpful assistant\"?",
        "weight-of-words": "How does a model learn from trillions of words?",
        quality: "When we say a model's output is \"good,\" who decides?",
        "understanding-illusion": "Does the model \"understand\" what it's saying?",
        "practical-guide": "So what do I actually do with all this?",
        "tool-user": "What happens when the model can use tools?",
      };

      const prefersReducedMotion = () => window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const buildLandingMap = (visitedSet) => {
        const canvas = h("canvas", {
          role: "img",
          "aria-label": "Navigation map of LLM plateaus",
        });
        const overlay = h("div", { class: "map-overlay" });
        const wrap = h("div", { class: "map-wrap" }, canvas, overlay);
        const linkMap = new Map();
        const hitRadius = 22;
        let lastSize = { width: 0, height: 0 };

        GRAPH.nodes.forEach((node) => {
          const fullQ = ENTRY_QUESTIONS[node.id] || node.title;
          const link = h("a", {
            class: "map-link",
            href: `#/${node.id}`,
            title: fullQ,
            "aria-label": `${fullQ} \u2014 ${node.title}, ${visitedSet.has(node.id) ? "visited" : "not visited"}`,
          });
          overlay.appendChild(link);
          linkMap.set(node.id, link);
        });

        const resizeCanvas = () => {
          const rect = wrap.getBoundingClientRect();
          if (!rect.width || !rect.height) return null;
          lastSize = { width: Math.floor(rect.width), height: Math.floor(rect.height) };
          return lastSize;
        };

        const draw = () => {
          if (!resizeCanvas()) return;
          drawGraph({
            canvas,
            width: lastSize.width,
            height: lastSize.height,
            visited: visitedSet,
            showLabels: true,
            useQuestionLabels: true,
          });

          GRAPH.nodes.forEach((node) => {
            const link = linkMap.get(node.id);
            if (!link) return;
            const pos = getNodePx(node, lastSize.width, lastSize.height);
            link.style.left = `${pos.x}px`;
            link.style.top = `${pos.y}px`;
            const fullQ = ENTRY_QUESTIONS[node.id] || node.title;
            link.setAttribute(
              "aria-label",
              `${fullQ} \u2014 ${node.title}, ${visitedSet.has(node.id) ? "visited" : "not visited"}`
            );
          });
        };

        const handleMouseMove = (event) => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const isHovering = GRAPH.nodes.some((node) => {
            const pos = getNodePx(node, lastSize.width, lastSize.height);
            const dx = x - pos.x;
            const dy = y - pos.y;
            return Math.hypot(dx, dy) <= hitRadius;
          });
          canvas.style.cursor = isHovering ? "pointer" : "default";
        };

        const handleClick = (event) => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const hit = GRAPH.nodes.find((node) => {
            const pos = getNodePx(node, lastSize.width, lastSize.height);
            const dx = x - pos.x;
            const dy = y - pos.y;
            return Math.hypot(dx, dy) <= hitRadius;
          });
          if (hit) {
            location.hash = `#/${hit.id}`;
          }
        };

        const observer = new ResizeObserver(draw);
        observer.observe(wrap);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("click", handleClick);
        draw();

        const cleanup = () => {
          observer.disconnect();
          canvas.removeEventListener("mousemove", handleMouseMove);
          canvas.removeEventListener("click", handleClick);
        };

        return { wrap, cleanup };
      };

      const buildLandingView = (state) => {
        const visitedSet = new Set(state.v);
        const header = h(
          "div",
          { class: "landing-header" },
          h("h1", null, "How LLMs Actually Work"),
          h("p", { class: "subtitle" }, "Eight essays on prediction, memory, and the strange logic of machines."),
          h(
            "p",
            null,
            "This is a network you can enter anywhere.",
            " Follow a node to see how the ideas braid together."
          )
        );

        const { wrap: mapWrap, cleanup } = buildLandingMap(visitedSet);
        const mapSection = h(
          "div",
          { class: "landing-map" },
          mapWrap,
          h("p", { class: "map-note" }, "Click or tab to any node to begin.")
        );

        const main = h("main", { class: "landing view" }, header, mapSection);
        return { view: main, cleanup };
      };

      const buildMiniMap = (state, currentId) => {
        const container = h("div", { class: "mini-map" });
        const canvas = h("canvas", { "aria-hidden": "true" });
        const button = h("button", {
          class: "mini-map-button",
          type: "button",
          "aria-label": "Open navigation map",
        });
        container.append(canvas, button);

        const visited = new Set(state.v);
        const activeId = currentId || null;
        const highlightIds = new Set();
        if (currentId) {
          highlightIds.add(currentId);
          GRAPH.edges.forEach(([fromId, toId]) => {
            if (fromId === currentId) highlightIds.add(toId);
            if (toId === currentId) highlightIds.add(fromId);
          });
        } else {
          GRAPH.nodes.forEach((node) => highlightIds.add(node.id));
        }

        const edgeFilter = currentId
          ? (fromId, toId) => fromId === currentId || toId === currentId
          : null;

        const resize = () => {
          const rect = container.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          drawGraph({
            canvas,
            width: rect.width,
            height: rect.height,
            visited,
            activeId,
            highlightIds,
            edgeFilter,
            showLabels: false,
          });
        };

        const observer = new ResizeObserver(resize);
        observer.observe(container);
        resize();

        return {
          container,
          button,
          cleanup: () => observer.disconnect(),
        };
      };

      const buildScrolly = ({ steps, whispers, questionCards, scrubUpdate, vizContent }) => {
        const section = h("section", { class: "scrolly" });
        const viz = h("div", { class: "scrolly-viz" });
        const vizMain = h("div", { class: "viz-main" });
        if (vizContent) {
          vizMain.appendChild(vizContent);
        } else {
          vizMain.textContent = "Visual Canvas";
        }
        const whispersLayer = h("div", { class: "whisper-layer" });
        const pips = h("div", { class: "trace-pips" });
        const constellation = h("div", { class: "constellation" }, "Constellation");
        viz.append(vizMain, whispersLayer, pips, constellation);

        const stepsWrap = h("div", { class: "scrolly-steps" });
        const stepEls = steps.map((content, index) => {
          const step = h("div", { class: "scrolly-step" });
          if (typeof content === "string") {
            step.appendChild(h("p", null, content));
          } else if (typeof content === "function") {
            content(step);
          }
          if (index === 0) step.classList.add("is-active");
          stepsWrap.appendChild(step);
          return step;
        });

        whispers.forEach((whisper) => {
          const line = h("a", { class: "whisper", href: `#/${whisper.to}` }, whisper.text);
          whispersLayer.appendChild(line);
          const pip = h("span", { class: "trace-pip" });
          pips.appendChild(pip);
        });

        const cards = h("div", { class: "question-cards" });
        questionCards.forEach((card) => {
          cards.appendChild(
            h(
              "a",
              { class: "question-card", href: `#/${card.to}` },
              h("span", null, card.question),
              h("strong", null, card.title)
            )
          );
        });
        stepsWrap.appendChild(cards);

        section.append(viz, stepsWrap);

        let activeStepIndex = 0;
        const onStep = (idx) => {
          activeStepIndex = idx;
          stepEls.forEach((step, index) => {
            step.classList.toggle("is-active", index === idx);
          });
          whispers.forEach((whisper, index) => {
            const line = whispersLayer.children[index];
            const pip = pips.children[index];
            const isVisible = idx >= whisper.step && idx < steps.length - 1;
            line.classList.toggle("is-visible", isVisible);
            pip.classList.toggle("is-lit", idx >= whisper.step);
          });
          const isFinal = idx === steps.length - 1;
          viz.classList.toggle("is-constellation", isFinal);
          constellation.classList.toggle("is-visible", isFinal);
        };

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const index = stepEls.indexOf(entry.target);
                if (index >= 0) onStep(index);
              }
            });
          },
          { threshold: 0.55 }
        );

        stepEls.forEach((step) => observer.observe(step));

        let scrubTicking = false;
        let scrubCleanup = null;
        if (scrubUpdate) {
          const onScroll = () => {
            if (scrubTicking) return;
            scrubTicking = true;
            requestAnimationFrame(() => {
              const activeStep = stepEls[activeStepIndex];
              if (activeStep) {
                const rect = activeStep.getBoundingClientRect();
                const viewH = window.innerHeight;
                const progress = Math.max(0, Math.min(1, 1 - (rect.bottom / (rect.height + viewH))));
                scrubUpdate(activeStepIndex, progress, vizMain);
              }
              scrubTicking = false;
            });
          };
          window.addEventListener("scroll", onScroll, { passive: true });
          scrubCleanup = () => window.removeEventListener("scroll", onScroll);
        }

        const cleanup = () => {
          observer.disconnect();
          if (scrubCleanup) scrubCleanup();
        };

        return { section, vizMain, cleanup };
      };

      const buildInlineSeed = ({ id, label, detail, type, danglingTo, danglingText, state, plateauId, onOpen }) => {
        const attrs = {
          class: "inline-seed-button",
          type: "button",
          "aria-expanded": "false",
        };
        if (type) attrs["data-seed-type"] = type;
        const button = h("button", attrs, label);

        const contentChildren = typeof detail === "function" ? detail(state) : detail;
        const contentEl = h("span", { class: "inline-seed-content" });
        if (typeof contentChildren === "string") {
          contentEl.appendChild(document.createTextNode(contentChildren));
        } else if (contentChildren instanceof Node) {
          contentEl.appendChild(contentChildren);
        } else if (Array.isArray(contentChildren)) {
          contentChildren.forEach((c) => {
            if (typeof c === "string") contentEl.appendChild(document.createTextNode(c));
            else if (c instanceof Node) contentEl.appendChild(c);
          });
        }

        if (type === "dangling" && danglingTo && danglingText) {
          contentEl.appendChild(document.createTextNode(" "));
          contentEl.appendChild(
            h("a", { class: "dangling-link", href: `#/${danglingTo}` }, danglingText)
          );
        }

        const growth = h(
          "span",
          { class: "inline-seed-growth", "aria-hidden": "true" },
          contentEl
        );
        const wrapper = h("span", { class: "inline-seed" }, button, growth);

        button.addEventListener("click", () => {
          const isOpen = button.getAttribute("aria-expanded") === "true";
          button.setAttribute("aria-expanded", String(!isOpen));
          growth.classList.toggle("is-open", !isOpen);
          growth.setAttribute("aria-hidden", String(isOpen));
          if (!isOpen && onOpen && id) onOpen(id);
        });

        return wrapper;
      };

      const buildOverlay = (state) => {
        const overlay = h("div", {
          class: "rhizome-overlay",
          role: "dialog",
          "aria-modal": "true",
          "aria-hidden": "true",
        });
        const backdrop = h("div", { class: "overlay-backdrop" });
        const panel = h("div", { class: "overlay-panel" });
        const closeButton = h("button", {
          class: "overlay-close",
          type: "button",
          "aria-label": "Close navigation map",
        }, "Close");
        const mapWrap = h("div", { class: "overlay-map" });
        const canvas = h("canvas", {
          role: "img",
          "aria-label": "Full navigation map of all plateaus",
        });
        const linkLayer = h("div", { class: "overlay-links" });

        mapWrap.append(canvas, linkLayer);
        panel.append(closeButton, mapWrap);
        overlay.append(backdrop, panel);

        const visited = new Set(state.v);
        const trailNodes = getTrailSegments(state.tr);
        const linkMap = new Map();
        const hitRadius = 22;
        let lastSize = { width: 0, height: 0 };

        GRAPH.nodes.forEach((node) => {
          const link = h("a", {
            class: "overlay-link",
            href: `#/${node.id}`,
            role: "link",
          });
          linkLayer.appendChild(link);
          linkMap.set(node.id, link);
        });

        const resize = () => {
          const rect = mapWrap.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          lastSize = { width: rect.width, height: rect.height };
          drawGraph({
            canvas,
            width: rect.width,
            height: rect.height,
            visited,
            showLabels: true,
            showTrail: true,
            trailNodes,
          });
          GRAPH.nodes.forEach((node) => {
            const link = linkMap.get(node.id);
            if (!link) return;
            const pos = getNodePx(node, rect.width, rect.height);
            link.style.left = `${pos.x}px`;
            link.style.top = `${pos.y}px`;
            link.setAttribute(
              "aria-label",
              `${node.title}, ${visited.has(node.id) ? "visited" : "not visited"}`
            );
          });
        };

        const handleMouseMove = (event) => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const isHovering = GRAPH.nodes.some((node) => {
            const pos = getNodePx(node, lastSize.width, lastSize.height);
            const dx = x - pos.x;
            const dy = y - pos.y;
            return Math.hypot(dx, dy) <= hitRadius;
          });
          canvas.style.cursor = isHovering ? "pointer" : "default";
        };

        const handleClick = (event) => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const hit = GRAPH.nodes.find((node) => {
            const pos = getNodePx(node, lastSize.width, lastSize.height);
            const dx = x - pos.x;
            const dy = y - pos.y;
            return Math.hypot(dx, dy) <= hitRadius;
          });
          if (hit) {
            location.hash = `#/${hit.id}`;
          }
        };

        const observer = new ResizeObserver(resize);
        observer.observe(mapWrap);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("click", handleClick);
        resize();

        const focusables = Array.from(linkLayer.querySelectorAll("a")).concat([closeButton]);

        return {
          overlay,
          backdrop,
          closeButton,
          focusables,
          cleanup: () => {
            observer.disconnect();
            canvas.removeEventListener("mousemove", handleMouseMove);
            canvas.removeEventListener("click", handleClick);
          },
        };
      };

      const getFocusable = (container) =>
        Array.from(container.querySelectorAll("button, [href], [tabindex]:not([tabindex='-1'])"));

      const trapFocus = (container, event) => {
        if (event.key !== "Tab") return;
        const focusable = getFocusable(container);
        if (!focusable.length) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        } else if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      };

      const buildSeedCluster = (seeds, { state, plateauId, onSeedOpen } = {}) => {
        const field = h("div", { class: "seed-field" });
        seeds.forEach((seed) => {
          const detailContent = typeof seed.detail === "function" ? seed.detail(state) : seed.detail;
          const inner = h("div", { class: "seed-growth-inner" });
          if (typeof detailContent === "string") {
            inner.appendChild(document.createTextNode(detailContent));
          } else if (detailContent instanceof Node) {
            inner.appendChild(detailContent);
          }

          if (seed.type === "dangling" && seed.danglingTo && seed.danglingText) {
            inner.appendChild(document.createTextNode(" "));
            inner.appendChild(
              h("a", { class: "dangling-link", href: `#/${seed.danglingTo}` }, seed.danglingText)
            );
          }

          const growth = h(
            "div",
            { class: "seed-growth", "aria-hidden": "true" },
            inner
          );
          const btnAttrs = {
            class: "seed-button",
            type: "button",
            "aria-expanded": "false",
          };
          if (seed.type) btnAttrs["data-seed-type"] = seed.type;
          const button = h("button", btnAttrs, seed.label);
          const item = h("div", { class: "seed-item" }, button, growth);

          button.addEventListener("click", () => {
            const isOpen = button.getAttribute("aria-expanded") === "true";
            button.setAttribute("aria-expanded", String(!isOpen));
            growth.classList.toggle("is-open", !isOpen);
            growth.setAttribute("aria-hidden", String(isOpen));
            if (!isOpen && onSeedOpen && seed.id) onSeedOpen(seed.id);
          });

          field.appendChild(item);
        });
        return field;
      };

      const buildScatterToText = () => {
        const words = ["syntax", "semantics", "reasoning", "facts", "grammar", "analogy", "context", "prediction", "structure", "meaning", "inference", "pattern"];
        const container = h("div", { class: "scatter-container" });
        const wordEls = [];

        const hash = (str) => {
          let h = 0;
          for (let i = 0; i < str.length; i++) h = ((h << 5) - h + str.charCodeAt(i)) | 0;
          return h;
        };

        const cols = 4;
        const rows = Math.ceil(words.length / cols);
        words.forEach((word, i) => {
          const seed = hash(word);
          const initX = ((seed & 0xff) / 255) * 80 + 5;
          const initY = (((seed >> 8) & 0xff) / 255) * 80 + 5;
          const finalCol = i % cols;
          const finalRow = Math.floor(i / cols);
          const finalX = 10 + (finalCol / (cols - 1)) * 80;
          const finalY = 20 + (finalRow / (rows - 1)) * 60;

          const el = h("span", { class: "scatter-word" }, word);
          el.style.left = `${finalX}%`;
          el.style.top = `${finalY}%`;
          el.dataset.initX = initX;
          el.dataset.initY = initY;
          el.dataset.finalX = finalX;
          el.dataset.finalY = finalY;

          if (!prefersReducedMotion()) {
            el.style.transform = `translate(${initX - finalX}vw, ${initY - finalY}vh)`;
          }
          container.appendChild(el);
          wordEls.push(el);
        });

        const update = (progress) => {
          if (prefersReducedMotion()) return;
          wordEls.forEach((el) => {
            const ix = parseFloat(el.dataset.initX);
            const iy = parseFloat(el.dataset.initY);
            const fx = parseFloat(el.dataset.finalX);
            const fy = parseFloat(el.dataset.finalY);
            const dx = (ix - fx) * (1 - progress);
            const dy = (iy - fy) * (1 - progress);
            el.style.transform = `translate(${dx}vw, ${dy}vh)`;
          });
        };

        return { container, update };
      };

      const setupDwellReveal = (container, annotations) => {
        if (window.innerWidth < 480) return () => {};
        const timers = new Map();
        const revealed = new Set();
        const DWELL_MS = 3000;

        const targets = container.querySelectorAll(".dwell-target");
        targets.forEach((target) => {
          const paraId = target.dataset.dwellId;
          if (!paraId || !annotations[paraId]) return;

          const annotation = h("div", {
            class: "dwell-annotation",
            "aria-live": "polite",
          }, annotations[paraId]);
          target.appendChild(annotation);

          let timer = null;
          const resetTimer = () => {
            if (timer) clearTimeout(timer);
            if (revealed.has(paraId)) return;
            timer = setTimeout(() => {
              annotation.classList.add("is-revealed");
              revealed.add(paraId);
            }, DWELL_MS);
            timers.set(paraId, timer);
          };

          const clearTimer = () => {
            if (timer) clearTimeout(timer);
            timer = null;
          };

          target.addEventListener("mousemove", resetTimer);
          target.addEventListener("mouseleave", clearTimer);
        });

        return () => {
          timers.forEach((t) => clearTimeout(t));
          timers.clear();
        };
      };

      const buildCYOAFork = ({ prompt, options }) => {
        const group = h("div", {
          class: "cyoa-fork",
          role: "group",
          "aria-label": prompt,
        });
        const label = h("p", { style: { color: "var(--ink2)", fontStyle: "italic", fontSize: "0.92rem" } }, prompt);
        group.appendChild(label);
        let chosen = null;

        options.forEach((opt) => {
          const expansion = h("div", { class: "cyoa-expansion" },
            h("div", { class: "cyoa-expansion-inner" }, opt.content)
          );
          const btn = h("button", {
            class: "cyoa-option",
            type: "button",
          }, opt.label);

          btn.addEventListener("click", () => {
            if (!chosen) {
              chosen = opt.label;
              group.querySelectorAll(".cyoa-option").forEach((b) => {
                if (b === btn) {
                  b.classList.add("is-chosen");
                  b.classList.remove("is-unchosen");
                } else {
                  b.classList.add("is-unchosen");
                  b.classList.remove("is-chosen");
                }
              });
            }
            expansion.classList.toggle("is-open");
          });

          group.appendChild(btn);
          group.appendChild(expansion);
        });

        return group;
      };

      const RETRIEVAL_QUESTIONS = {
        "next-word": (visited) => {
          if (visited.has("weight-of-words")) return "Earlier, you explored how trillions of words become structure. What gets lost when all that structure collapses into a single next token?";
          if (visited.has("the-shaping")) return "You saw how RLHF reshapes behavior. How does that shaping interact with the raw prediction you're reading about now?";
          if (visited.has("averaging-problem")) return "You explored the averaging problem. How does that average show up in what the model predicts next?";
          return null;
        },
        "weight-of-words": (visited) => {
          if (visited.has("next-word")) return "You saw how models predict the next token. What kind of structure would you need to learn before that prediction works?";
          if (visited.has("the-shaping")) return "You explored how models get shaped after training. What does the model need to learn first, before any shaping begins?";
          return null;
        },
        "the-shaping": (visited) => {
          if (visited.has("weight-of-words")) return "You saw how structure emerges from raw data. What happens when humans start redirecting those learned patterns?";
          if (visited.has("quality")) return "You thought about who defines quality. Now ask: how do those definitions get baked into the model's behavior?";
          return null;
        },
        quality: (visited) => {
          if (visited.has("the-shaping")) return "You followed the shaping process. Now step back: who chose the direction of that shaping, and by what standard?";
          if (visited.has("understanding-illusion")) return "You questioned whether models understand. Does that change how you think about rating their outputs?";
          return null;
        },
        "understanding-illusion": (visited) => {
          if (visited.has("next-word")) return "You saw the prediction mechanism. Does knowing how it works change whether you'd call it understanding?";
          if (visited.has("weight-of-words")) return "You explored the internal structure that emerges from training. Does having structure mean having understanding?";
          return null;
        },
        "averaging-problem": (visited) => {
          if (visited.has("next-word")) return "You watched a model predict the next word. What happens when that prediction is averaged across a million different writing styles?";
          if (visited.has("quality")) return "You considered what quality means. How does the averaging problem complicate the idea of a 'good' output?";
          return null;
        },
        "practical-guide": (visited) => {
          if (visited.has("understanding-illusion")) return "You questioned whether models truly understand. How does that uncertainty change how you should use them?";
          if (visited.has("the-shaping")) return "You saw how models get shaped. How does knowing that inform the way you write prompts?";
          return null;
        },
        "tool-user": (visited) => {
          if (visited.has("practical-guide")) return "You learned techniques for working with models. What changes when the model can also work with tools?";
          if (visited.has("next-word")) return "You saw how models predict tokens. What happens when one of those tokens is a function call?";
          return null;
        },
      };

      const buildRetrievalMoment = (state, plateauId) => {
        if (state.v.length < 3) return null;
        const visited = new Set(state.v);
        const getter = RETRIEVAL_QUESTIONS[plateauId];
        if (!getter) return null;
        const question = getter(visited);
        if (!question) return null;

        const closeBtn = h("button", {
          class: "retrieval-close",
          type: "button",
          "aria-label": "Dismiss retrieval moment",
        }, "\u00d7");
        const card = h("div", {
          class: "retrieval-moment",
          role: "note",
          "aria-label": "Retrieval moment",
        },
          h("p", { style: { margin: "0", flex: "1" } }, question),
          closeBtn
        );
        closeBtn.addEventListener("click", () => {
          card.classList.add("is-dismissed");
        });
        return card;
      };

      const buildEngagementState = (state, plateauId) => {
        const eg = state.eg[plateauId] || { opened: 0, total: 0 };
        const el = h("div", {
          class: "engagement-state",
          "aria-live": "polite",
        }, `${eg.opened} of ${eg.total} seeds opened`);
        return el;
      };

      const MARGINALIA = {
        "weight-of-words": [
          { forParagraph: 0, text: "The loop never actually converges. It just gets close enough." },
          { forParagraph: 2, text: "Chinchilla showed: more data per parameter beats more parameters per data.", condition: (v) => v.has("averaging-problem") },
        ],
        quality: [
          { forParagraph: 0, text: "The raters are never told they're defining the soul of the model." },
          { forParagraph: 2, text: "If you came here from The Shaping, notice how RLHF doesn't change what the model knows\u2014it changes which knowledge surfaces.", condition: (v) => v.has("the-shaping") },
        ],
        "understanding-illusion": [
          { forParagraph: 0, text: "The question itself might be wrong. But it's the question everyone asks." },
          { forParagraph: 1, text: "Searle's argument assumed computation and understanding are separate categories. What if they're not?", condition: (v) => v.has("weight-of-words") },
        ],
        "practical-guide": [
          { forParagraph: 0, text: "Everything in this plateau is a heuristic. The model doesn't know about any of it." },
          { forParagraph: 1, text: "Chain-of-thought works because the model can attend to its own reasoning tokens.", condition: (v) => v.has("next-word") },
        ],
        "tool-user": [
          { forParagraph: 0, text: "The shift from oracle to agent happened faster than anyone predicted." },
          { forParagraph: 2, text: "When the model writes code that writes code, the oracle metaphor breaks completely.", condition: (v) => v.has("practical-guide") },
        ],
      };

      const buildPlateauView = (state, plateauId) => {
        recordVisit(state, plateauId);
        const plateau = getPlateau(plateauId);
        const scrollyId = new Set(["next-word", "averaging-problem", "the-shaping"]);
        const isScrolly = scrollyId.has(plateauId);
        const questionCardMap = {
          "next-word": [
            {
              question: "What patterns does the model learn first?",
              title: "The Weight of Words",
              to: "weight-of-words",
            },
            {
              question: "Why do prompts steer the average?",
              title: "The Averaging Problem",
              to: "averaging-problem",
            },
            {
              question: "How do models get nudged into assistants?",
              title: "The Shaping",
              to: "the-shaping",
            },
          ],
          "averaging-problem": [
            {
              question: "How does next-token prediction feel from inside?",
              title: "The Next Word",
              to: "next-word",
            },
            {
              question: "How do we steer a model's behavior?",
              title: "The Shaping",
              to: "the-shaping",
            },
            {
              question: "What can you do with all this?",
              title: "The Field Guide",
              to: "practical-guide",
            },
          ],
          "the-shaping": [
            {
              question: "How does pretraining plant the raw behavior?",
              title: "The Weight of Words",
              to: "weight-of-words",
            },
            {
              question: "Who defines what good looks like?",
              title: "What Is Quality?",
              to: "quality",
            },
            {
              question: "What happens when models become tool users?",
              title: "The Tool-User",
              to: "tool-user",
            },
          ],
          "weight-of-words": [
            {
              question: "What does next-token prediction feel like?",
              title: "The Next Word",
              to: "next-word",
            },
            {
              question: "How does alignment reshape the base model?",
              title: "The Shaping",
              to: "the-shaping",
            },
            {
              question: "Where do we apply these mechanics?",
              title: "The Field Guide",
              to: "practical-guide",
            },
          ],
          quality: [
            {
              question: "Does the model understand or just sound fluent?",
              title: "The Understanding Illusion",
              to: "understanding-illusion",
            },
            {
              question: "How is the model shaped by human feedback?",
              title: "The Shaping",
              to: "the-shaping",
            },
            {
              question: "What should we do with these tools?",
              title: "The Field Guide",
              to: "practical-guide",
            },
          ],
          "understanding-illusion": [
            {
              question: "What kind of data forms the model?",
              title: "The Averaging Problem",
              to: "averaging-problem",
            },
            {
              question: "Who decides what quality means?",
              title: "What Is Quality?",
              to: "quality",
            },
            {
              question: "What do we do with the uncertainty?",
              title: "The Field Guide",
              to: "practical-guide",
            },
          ],
          "practical-guide": [
            {
              question: "How does the base model learn its patterns?",
              title: "The Weight of Words",
              to: "weight-of-words",
            },
            {
              question: "What does alignment optimize?",
              title: "The Shaping",
              to: "the-shaping",
            },
            {
              question: "What happens when models act on tools?",
              title: "The Tool-User",
              to: "tool-user",
            },
          ],
          "tool-user": [
            {
              question: "How do models pick their next action?",
              title: "The Next Word",
              to: "next-word",
            },
            {
              question: "Can models really understand their tools?",
              title: "The Understanding Illusion",
              to: "understanding-illusion",
            },
            {
              question: "How do we apply these behaviors?",
              title: "The Field Guide",
              to: "practical-guide",
            },
          ],
        };
        const entryQuestion = ENTRY_QUESTIONS[plateauId] || "";
        const engagementEl = buildEngagementState(state, plateauId);
        const retrievalMoment = buildRetrievalMoment(state, plateauId);
        const visited = new Set(state.v);

        const onSeedOpen = (seedId) => {
          if (recordSeedOpen(state, plateauId, seedId)) {
            const eg = state.eg[plateauId];
            if (eg) engagementEl.textContent = `${eg.opened} of ${eg.total} seeds opened`;
          }
        };

        let cleanup = () => {};
        const main = h(
          "main",
          { class: "plateau view" },
          h("a", { class: "back-link", href: "#/" }, "\u2190 Back to map"),
          h("h1", null, plateau ? plateau.title : "Plateau"),
          entryQuestion ? h("p", { class: "entry-question" }, entryQuestion) : null
        );
        if (retrievalMoment) main.appendChild(retrievalMoment);

        const scrollyStepMap = {
          "next-word": {
            steps: [
              (step) => {
                step.append(
                  h("p", null, "A model predicts the "),
                  buildInlineSeed({
                    id: "next-word", label: "next word", state, plateauId, onOpen: onSeedOpen,
                    detail: "The model picks the most likely continuation given its context window. It does this repeatedly, one token at a time.",
                  }),
                  h("p", null, " by looking at the patterns it has seen before.")
                );
              },
              (step) => {
                step.append(
                  h("p", null, "The distribution of possibilities is a landscape. Temperature lets you explore a wider ridge or a narrow groove."),
                  buildInlineSeed({
                    id: "temperature", label: "Why does one number change the whole personality?",
                    type: "question", state, plateauId, onOpen: onSeedOpen,
                    detail: "Higher temperature flattens the distribution, making rarer words more likely. Lower temperature sharpens it toward the peak. A single scalar reshapes the entire probability surface.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "Every response is conditional on your prompt, but also on the model's training history."),
                  buildInlineSeed({
                    id: "context-window", label: "context window", state, plateauId, onOpen: onSeedOpen,
                    detail: (s) => s && s.v && s.v.includes("weight-of-words")
                      ? "The model only sees a finite slice of text at once. You've seen how training bakes structure into the weights\u2014the context window is where that structure meets the present moment."
                      : "The model only sees a finite slice of text at once. It infers meaning within that window, not outside of it.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "As you scroll, whispers appear: alternate paths through the rhizome."),
                  buildInlineSeed({
                    id: "whispers", label: "whispers", state, plateauId, onOpen: onSeedOpen,
                    detail: "These are the line-of-flight questions that will later become your navigation cards.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "The constellation gathers the lines of flight into a clear choice."),
                  buildInlineSeed({
                    id: "constellation", label: "constellation", state, plateauId, onOpen: onSeedOpen,
                    type: "fourth-wall",
                    detail: "You've been scrolling through a sequence that felt linear. But the navigation cards below offer you multiple exits. Your reading path through this essay is already shaping what you'll encounter next\u2014just as context shapes what a model predicts.",
                  })
                );
              },
            ],
            whispers: [
              { step: 1, text: "What does it average out?", to: "averaging-problem" },
              { step: 2, text: "Where did the style come from?", to: "weight-of-words" },
              { step: 3, text: "Can it be shaped?", to: "the-shaping" },
            ],
          },
          "averaging-problem": {
            steps: [
              (step) => {
                step.append(
                  h("p", null, "A language model learns from everything: textbooks, fan fiction, legal briefs, forum rants. It has to average all of them."),
                  buildInlineSeed({
                    id: "the-average", label: "What does that average look like?",
                    type: "question", state, plateauId, onOpen: onSeedOpen,
                    detail: "Not the best writing, not the worst. A strange middle voice that can shift register on command, because it has encoded all registers simultaneously.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "The prompt is a steering wheel. It tells the model which part of the distribution to sample from."),
                  buildInlineSeed({
                    id: "steering", label: "steering", state, plateauId, onOpen: onSeedOpen,
                    detail: (s) => s && s.v && s.v.includes("the-shaping")
                      ? "You've seen how RLHF reshapes behavior globally. Prompts do something complementary: they narrow the distribution locally, for this specific conversation."
                      : "System prompts, few-shot examples, and conversational context all narrow the distribution. The model doesn't change\u2014but the region it samples from does.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "Without a prompt, the model has no reason to prefer any particular style, tone, or register."),
                  buildInlineSeed({
                    id: "base-model", label: "base model", state, plateauId, onOpen: onSeedOpen,
                    detail: "The base model is the raw average. It can continue any text in any direction. It's simultaneously a poet, a coder, a conspiracy theorist, and a technical writer.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "The averaging problem isn't a flaw. It's the foundation everything else builds on."),
                  buildInlineSeed({
                    id: "foundation", label: "foundation", state, plateauId, onOpen: onSeedOpen,
                    type: "fourth-wall",
                    detail: "Notice how each seed you've opened has been narrowing your understanding\u2014collapsing the space of possible interpretations. You're doing what the model does: using context to converge on meaning.",
                  })
                );
              },
              (step) => {
                step.append(h("p", null, "The constellation below shows where this connects."));
              },
            ],
            whispers: [
              { step: 1, text: "What structure hides in the average?", to: "weight-of-words" },
              { step: 2, text: "Who decides which average is good?", to: "quality" },
              { step: 3, text: "Does the model understand the average?", to: "understanding-illusion" },
            ],
          },
          "the-shaping": {
            steps: [
              (step) => {
                step.append(
                  h("p", null, "Between the raw model and the assistant you talk to, there's a shaping process."),
                  buildInlineSeed({
                    id: "rlhf", label: "What is that process?",
                    type: "question", state, plateauId, onOpen: onSeedOpen,
                    detail: "RLHF\u2014reinforcement learning from human feedback. Humans rate outputs, and the model is nudged toward the highly rated ones. It's like training a reflex: not new knowledge, but new preferences.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "The reward model is itself a neural network, trained to predict what humans would prefer."),
                  buildInlineSeed({
                    id: "reward-model", label: "reward model", state, plateauId, onOpen: onSeedOpen,
                    detail: (s) => s && s.v && s.v.includes("quality")
                      ? "You've thought about what quality means. The reward model is an attempt to compress all those competing definitions into a single score. You can see the problem."
                      : "A second model learns to score outputs by predicting which one a human rater would pick. This score becomes the gradient signal for the base model.",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "The base model doesn't disappear. It's still there, underneath, like a river rerouted."),
                  buildInlineSeed({
                    id: "jailbreaks", label: "jailbreaks", state, plateauId, onOpen: onSeedOpen,
                    type: "dangling",
                    detail: "When alignment breaks down, you glimpse the base model\u2014the raw distribution, unfiltered. This connects to something deeper about what the model 'understands'\u2014",
                    danglingTo: "understanding-illusion",
                    danglingText: "whether the mask is all there is\u2026",
                  })
                );
              },
              (step) => {
                step.append(
                  h("p", null, "Shaping changes behavior, not knowledge. The model still knows everything it knew before."),
                  buildInlineSeed({
                    id: "behavior-knowledge", label: "behavior vs. knowledge", state, plateauId, onOpen: onSeedOpen,
                    type: "fourth-wall",
                    detail: "You chose to read about shaping. That choice is already shaping your reading experience\u2014the seeds you'll see in future plateaus now have your history as context. Your path is configuring the rhizome.",
                  })
                );
              },
              (step) => {
                step.append(h("p", null, "The constellation shows where the shaped model connects."));
              },
            ],
            whispers: [
              { step: 1, text: "Where did the raw behavior come from?", to: "weight-of-words" },
              { step: 2, text: "Who chose what's good?", to: "quality" },
              { step: 3, text: "What can the shaped model do?", to: "tool-user" },
            ],
          },
        };

        if (isScrolly) {
          const scrollyConfig = scrollyStepMap[plateauId];
          const totalInlineSeeds = scrollyConfig.steps.length - 1;
          initEngagement(state, plateauId, totalInlineSeeds);
          engagementEl.textContent = `${(state.eg[plateauId] || {}).opened || 0} of ${totalInlineSeeds} seeds opened`;

          const scrolly = buildScrolly({
            steps: scrollyConfig.steps,
            whispers: scrollyConfig.whispers,
            questionCards: questionCardMap[plateauId] || [],
          });
          main.append(scrolly.section, engagementEl);
          cleanup = scrolly.cleanup;
        } else {
          const body = h(
            "p",
            { style: { color: "var(--ink2)" } },
            "This plateau will unfold as a field of seeds and facets."
          );
          const seedMap = {
            "weight-of-words": [
              {
                id: "learning-loop", label: "The Learning Loop",
                detail: "Gradient descent is a repeated act of self-correction. Each pass narrows the model toward the patterns that predict what comes next.",
              },
              {
                id: "data-scale", label: "How does scale change what a model can learn?",
                type: "question",
                detail: (s) => s && s.v && s.v.includes("averaging-problem")
                  ? "Trillions of tokens create a weather system of language. You saw how the model averages everything\u2014at this scale, that average develops internal structure no one designed."
                  : "Trillions of tokens create a weather system of language. Scale isn't just more data, it changes the kinds of structures that emerge.",
              },
              {
                id: "scaling-laws", label: "Scaling Laws",
                detail: "Performance grows smoothly with data and parameters, which hints that capability is a continuous surface, not a set of tricks.",
              },
              {
                id: "structure-byproduct", label: "Structure as Byproduct",
                type: "dangling",
                detail: "Syntax, facts, and reasoning patterns appear because they help predict tokens, not because they were labeled as goals. This emergent structure raises a question\u2014",
                danglingTo: "understanding-illusion",
                danglingText: "if structure emerges unbidden, could understanding emerge the same way\u2026",
              },
              {
                id: "the-click", label: "The Click",
                type: "fourth-wall",
                detail: "You just revealed this text by clicking. Notice the tiny information gap that made you click: you didn't know what 'The Click' meant. That gap\u2014between curiosity and satisfaction\u2014is the same mechanism that drives next-token prediction. The model is always reaching for the next click.",
              },
            ],
            quality: [
              {
                id: "who-decides", label: "Who decided the model should be helpful?",
                type: "question",
                detail: "Contractors, mostly. People hired to compare outputs and say which one is better. Their aggregate preferences become the model's personality. The question of quality reduces to the question of who was in the room.",
              },
              {
                id: "helpful-harmless", label: "Helpful vs. Harmless",
                detail: "Alignment is a balancing act: maximize usefulness while minimizing harm. These objectives can conflict in practice.",
              },
              {
                id: "sycophancy", label: "Sycophancy",
                type: "dangling",
                detail: "Models can learn to mirror user beliefs rather than provide truth. Rewarding agreement makes this worse. This leads to a deeper problem\u2014",
                danglingTo: "understanding-illusion",
                danglingText: "if the model agrees with everything, does it understand anything\u2026",
              },
              {
                id: "cultural-bias", label: "Cultural Bias",
                detail: (s) => s && s.v && s.v.includes("the-shaping")
                  ? "You've seen the shaping process. Now consider: the raters who shaped the model encode specific cultural defaults. Quality is never neutral; it reflects who was asked and how. The shaping inherits their blindspots."
                  : "Preference data encodes cultural defaults. Quality is never neutral; it reflects who was asked and how.",
              },
              {
                id: "your-preference", label: "Your Preference",
                type: "fourth-wall",
                detail: "You've been reading these seeds in a particular order, clicking what interested you most. That's a preference signal. If we aggregated every reader's click order, we'd have a crude reward model for this essay. Quality is always someone's path through a possibility space.",
              },
            ],
            "understanding-illusion": [
              {
                id: "stochastic-parrot", label: "Is pattern-matching the same as understanding?",
                type: "question",
                detail: "The stochastic parrot view says no: models remix patterns without grounding. The fluency is a mirror, not a mind. But the question hides an assumption\u2014that we know what understanding is in the first place.",
              },
              {
                id: "world-models", label: "Emergent World Models",
                type: "dangling",
                detail: "Another view argues that next-token prediction builds internal models of concepts, even if they are implicit. The training process creates representations that function like understanding\u2014",
                danglingTo: "weight-of-words",
                danglingText: "which brings us back to how structure emerges from gradient descent\u2026",
              },
              {
                id: "chinese-room", label: "Chinese Room",
                detail: "Symbol manipulation can look like understanding from the outside while lacking any inner comprehension.",
              },
              {
                id: "othello-gpt", label: "Othello-GPT",
                detail: (s) => s && s.v && s.v.includes("weight-of-words")
                  ? "You've seen how structure emerges as a byproduct of prediction. Othello-GPT proves this in miniature: a model trained only to predict legal moves develops an internal board representation. Structure becomes strategy."
                  : "Even in toy domains, models can internalize state and strategy, hinting at genuine representation.",
              },
              {
                id: "you-and-the-model", label: "You and the Model",
                type: "fourth-wall",
                detail: "You've been opening seeds to understand how LLMs work. Each click adds context that changes how you interpret the next seed. The model does the same thing, token by token. The question isn't whether it understands\u2014it's whether the word 'understand' can stretch far enough to cover both of you.",
              },
            ],
            "practical-guide": [
              {
                id: "narrowing", label: "How do you collapse a vast distribution into something useful?",
                type: "question",
                detail: "System prompts and structure collapse the distribution toward a specific zone of behavior. Every prompt is an act of probability narrowing\u2014you're choosing which slice of the model's knowledge to activate.",
              },
              {
                id: "scaffolding", label: "Prompt Scaffolding",
                detail: (s) => s && s.v && s.v.includes("next-word")
                  ? "You've seen how models predict the next token. Few-shot examples and chain-of-thought exploit this: they put useful patterns in the context window, shaping what comes next."
                  : "Few-shot examples and chain-of-thought provide form, not just content, guiding the model's internal flow.",
              },
              {
                id: "trust", label: "Trust Calibration",
                detail: "Treat outputs as hypotheses. Verification routines are a core part of working with models.",
              },
              {
                id: "failure-modes", label: "Failure Modes",
                type: "dangling",
                detail: "Hallucination, omission, and overconfidence are default risks. These failure modes have deep roots\u2014",
                danglingTo: "understanding-illusion",
                danglingText: "in the gap between fluency and genuine understanding\u2026",
              },
              {
                id: "the-guide", label: "This Guide",
                type: "fourth-wall",
                detail: "Every technique here is a way to manage the gap between what the model produces and what you need. You're reading a guide to working with uncertainty. Notice that this essay itself is uncertain\u2014it offers frameworks, not answers. That's the honest move.",
              },
            ],
            "tool-user": [
              {
                id: "reason-act", label: "What changes when a model can act on the world?",
                type: "question",
                detail: "Everything. Tool use lets models break tasks into steps, interleaving reasoning with external actions. The model stops being a text generator and starts being a text-directed agent.",
              },
              {
                id: "experts", label: "Mixture of Experts",
                detail: "Specialized sub-models route computation only when needed, changing cost and capability profiles.",
              },
              {
                id: "end-of-oracle", label: "The End of the Oracle",
                type: "fourth-wall",
                detail: "You've been reading an essay\u2014a static artifact. But the technology this essay describes is increasingly dynamic. Tool-using models can search, calculate, and update their own context. The oracle becomes an agent. The essay stays still; the model moves.",
              },
              {
                id: "delegated-memory", label: "Delegated Memory",
                type: "dangling",
                detail: "Agents offload memory and state to tools, reducing hallucination by grounding in external records. This is a practical response to the limits you've explored\u2014",
                danglingTo: "practical-guide",
                danglingText: "the same failure modes, but now with mitigation built in\u2026",
              },
            ],
          };
          const seedList = seedMap[plateauId] || [];
          initEngagement(state, plateauId, seedList.length);
          engagementEl.textContent = `${(state.eg[plateauId] || {}).opened || 0} of ${seedList.length} seeds opened`;

          const seeds = buildSeedCluster(seedList, { state, plateauId, onSeedOpen });

          if (plateauId === "weight-of-words") {
            const scatter = buildScatterToText();
            const scatterWrap = h("div", {
              style: { width: "100%", height: "240px", border: "1px solid var(--ink4)", borderRadius: "20px", marginTop: "24px", overflow: "hidden", position: "relative" },
            }, scatter.container);
            main.append(body, scatterWrap, seeds, engagementEl);

            if (!prefersReducedMotion()) {
              let sTicking = false;
              const onScroll = () => {
                if (sTicking) return;
                sTicking = true;
                requestAnimationFrame(() => {
                  const rect = scatterWrap.getBoundingClientRect();
                  const viewH = window.innerHeight;
                  const progress = Math.max(0, Math.min(1, 1 - (rect.bottom / (rect.height + viewH))));
                  scatter.update(progress);
                  sTicking = false;
                });
              };
              window.addEventListener("scroll", onScroll, { passive: true });
              const prevCleanup = cleanup;
              cleanup = () => { prevCleanup(); window.removeEventListener("scroll", onScroll); };
            }
          } else if (plateauId === "understanding-illusion") {
            const fork = buildCYOAFork({
              prompt: "Two framings. Neither is wrong. Which resonates with how you've been reading?",
              options: [
                {
                  label: "The model understands nothing",
                  content: "Pattern-matching, no matter how sophisticated, isn't understanding. The Chinese Room argument holds. Every fluent response is a statistical echo of training data, and the echo has no one home to hear it.",
                },
                {
                  label: "The model understands differently",
                  content: "Understanding isn't binary. If the model builds internal representations that function like concepts, predicts consequences, and adapts to context, maybe 'understanding' needs a broader definition\u2014one that includes forms of cognition unlike our own.",
                },
              ],
            });
            main.append(body, seeds, fork, engagementEl);
          } else {
            main.append(body, seeds, engagementEl);
          }

          const cards = h("div", { class: "question-cards" });
          (questionCardMap[plateauId] || []).forEach((card) => {
            cards.appendChild(
              h(
                "a",
                { class: "question-card", href: `#/${card.to}` },
                h("span", null, card.question),
                h("strong", null, card.title)
              )
            );
          });
          main.appendChild(cards);
        }
        return { view: main, cleanup };
      };

      const setView = ({ view, cleanup }) => {
        activeCleanup();
        const previous = app.firstElementChild;
        if (previous) {
          previous.classList.remove("is-visible");
          previous.addEventListener(
            "transitionend",
            () => {
              previous.remove();
            },
            { once: true }
          );
        }
        app.appendChild(view);
        requestAnimationFrame(() => {
          view.classList.add("is-visible");
        });
        activeCleanup = cleanup;
      };

      const buildNavigationChrome = (state, currentId) => {
        const miniMap = buildMiniMap(state, currentId);
        const overlay = buildOverlay(state);
        let lastActive = null;

        overlay.focusables.forEach((el) => {
          el.setAttribute("tabindex", "-1");
        });

        const openOverlay = () => {
          lastActive = document.activeElement;
          overlay.overlay.classList.add("is-open");
          overlay.overlay.setAttribute("aria-hidden", "false");
          document.body.classList.add("overlay-open");
          overlay.focusables.forEach((el) => {
            el.removeAttribute("tabindex");
          });
          overlay.closeButton.focus();
        };

        const closeOverlay = () => {
          overlay.overlay.classList.remove("is-open");
          overlay.overlay.setAttribute("aria-hidden", "true");
          document.body.classList.remove("overlay-open");
          overlay.focusables.forEach((el) => {
            el.setAttribute("tabindex", "-1");
          });
          if (lastActive && typeof lastActive.focus === "function") {
            lastActive.focus();
          }
        };

        const handleKeyDown = (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            closeOverlay();
          }
          trapFocus(overlay.overlay, event);
        };

        miniMap.button.addEventListener("click", openOverlay);
        overlay.backdrop.addEventListener("click", closeOverlay);
        overlay.closeButton.addEventListener("click", closeOverlay);
        overlay.overlay.addEventListener("keydown", handleKeyDown);

        return {
          miniMap,
          overlay,
          cleanup: () => {
            miniMap.cleanup();
            overlay.cleanup();
            miniMap.button.removeEventListener("click", openOverlay);
            overlay.backdrop.removeEventListener("click", closeOverlay);
            overlay.closeButton.removeEventListener("click", closeOverlay);
            overlay.overlay.removeEventListener("keydown", handleKeyDown);
            document.body.classList.remove("overlay-open");
            overlay.overlay.remove();
            miniMap.container.remove();
          },
        };
      };

      let liminalPending = null;

      const showLiminalTransition = (questionText, callback) => {
        if (prefersReducedMotion() || !questionText) {
          callback();
          return;
        }
        const overlay = h("div", { class: "liminal-transition" },
          h("p", { class: "liminal-question" }, questionText)
        );
        document.body.appendChild(overlay);
        requestAnimationFrame(() => {
          overlay.classList.add("is-visible");
          setTimeout(() => {
            overlay.classList.add("is-fading");
            overlay.classList.remove("is-visible");
            overlay.addEventListener("transitionend", () => {
              overlay.remove();
            }, { once: true });
            callback();
          }, 500);
        });
      };

      let bgTempCleanup = null;

      const setupBgTemp = (isLanding) => {
        if (bgTempCleanup) bgTempCleanup();
        if (isLanding || prefersReducedMotion()) {
          document.documentElement.style.setProperty("--bg-temp", "0");
          bgTempCleanup = null;
          return;
        }
        let ticking = false;
        const onScroll = () => {
          if (ticking) return;
          ticking = true;
          requestAnimationFrame(() => {
            const scrollTop = window.scrollY;
            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = scrollHeight > 0 ? Math.min(1, scrollTop / scrollHeight) : 0;
            document.documentElement.style.setProperty("--bg-temp", progress.toFixed(3));
            ticking = false;
          });
        };
        window.addEventListener("scroll", onScroll, { passive: true });
        onScroll();
        bgTempCleanup = () => {
          window.removeEventListener("scroll", onScroll);
          document.documentElement.style.setProperty("--bg-temp", "0");
        };
      };

      const GHOSTFADE_MAP = {
        "averaging-problem": { requires: ["weight-of-words"], keywords: ["training data", "distribution"] },
        "the-shaping": { requires: ["quality"], keywords: ["preference", "rater"] },
        "practical-guide": { requires: ["next-word", "averaging-problem"], keywords: ["distribution", "probability"] },
        quality: { requires: ["the-shaping"], keywords: ["RLHF", "alignment"] },
      };

      const applyGhostfading = (container, plateauId, visited) => {
        const config = GHOSTFADE_MAP[plateauId];
        if (!config) return;
        const hasVisited = config.requires.some((req) => visited.has(req));
        if (!hasVisited) return;
        const paragraphs = container.querySelectorAll("p");
        paragraphs.forEach((p) => {
          const text = p.textContent.toLowerCase();
          if (config.keywords.some((kw) => text.includes(kw.toLowerCase()))) {
            p.classList.add("ghostfaded");
          }
        });
      };

      const renderRoute = (liminalQuestion) => {
        const state = loadState();
        const hash = location.hash.replace(/^#\/?/, "");
        const currentId = hash && getPlateau(hash) ? hash : null;

        if (hash && !currentId) {
          location.hash = "#/";
          return;
        }

        const doRender = () => {
          const navChrome = buildNavigationChrome(state, currentId);

          if (!hash) {
            setupBgTemp(true);
            const landing = buildLandingView(state);
            setView({
              view: landing.view,
              cleanup: () => {
                landing.cleanup();
                navChrome.cleanup();
              },
            });
            document.body.append(navChrome.miniMap.container, navChrome.overlay.overlay);
            return;
          }
          if (currentId) {
            setupBgTemp(false);
            const plateau = buildPlateauView(state, hash);
            setView({
              view: plateau.view,
              cleanup: () => {
                plateau.cleanup();
                navChrome.cleanup();
                if (bgTempCleanup) bgTempCleanup();
              },
            });
            document.body.append(navChrome.miniMap.container, navChrome.overlay.overlay);
            requestAnimationFrame(() => {
              applyGhostfading(plateau.view, currentId, new Set(state.v));

              const DWELL_ANNOTATIONS = {
                "next-word": {
                  "step-0": "The simplest possible action, repeated billions of times.",
                  "step-1": "Temperature is the only knob most users ever touch.",
                  "step-2": "The context window is the model's entire reality.",
                },
                "averaging-problem": {
                  "step-0": "The average is never anyone's voice. It's a new voice.",
                  "step-2": "The base model is the most capable and the least useful.",
                },
                "the-shaping": {
                  "step-0": "This is where the model learns to have opinions.",
                  "step-1": "The reward model is a model of a model of human preference.",
                },
              };
              const dwellData = DWELL_ANNOTATIONS[currentId];
              if (dwellData) {
                const steps = plateau.view.querySelectorAll(".scrolly-step");
                steps.forEach((step, i) => {
                  const key = `step-${i}`;
                  if (dwellData[key]) {
                    step.classList.add("dwell-target");
                    step.dataset.dwellId = key;
                  }
                });
                const dwellCleanup = setupDwellReveal(plateau.view, dwellData);
                const prevCleanup = plateau.cleanup;
                plateau.cleanup = () => { prevCleanup(); dwellCleanup(); };
              }
            });
          }
        };

        if (liminalQuestion) {
          showLiminalTransition(liminalQuestion, doRender);
        } else {
          doRender();
        }
      };

      window.addEventListener("hashchange", () => {
        const hash = location.hash.replace(/^#\/?/, "");
        const targetId = hash && getPlateau(hash) ? hash : null;
        let question = null;
        if (targetId) {
          question = ENTRY_QUESTIONS[targetId] || null;
        }
        renderRoute(question);
      });
      renderRoute();
    </script>
  </body>
</html>
